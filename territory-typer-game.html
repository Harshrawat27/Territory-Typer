<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Territory Typer - Multiplayer Geography Typing Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background-color: #f0f2f5;
        color: #333;
        overflow: hidden;
      }

      #game-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        text-align: center;
        margin-bottom: 20px;
      }

      h1 {
        color: #2c3e50;
        margin-bottom: 10px;
      }

      #game-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
      }

      #timer,
      #scores {
        background-color: #fff;
        border-radius: 8px;
        padding: 10px 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      #timer {
        font-size: 24px;
        font-weight: bold;
        color: #e74c3c;
      }

      #map-container {
        position: relative;
        width: 100%;
        height: 500px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        margin-bottom: 20px;
      }

      .territory {
        position: absolute;
        cursor: pointer;
        transition: transform 0.2s;
        transform-origin: center;
      }

      .territory:hover {
        transform: scale(1.05);
      }

      .territory-label {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.85);
        border-radius: 4px;
        padding: 5px 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        font-size: 14px;
        pointer-events: none;
      }

      #typing-area {
        width: 100%;
        padding: 20px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      #current-phrase {
        font-size: 18px;
        margin-bottom: 10px;
      }

      #typing-input {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        border-radius: 4px;
        border: 2px solid #ddd;
        margin-bottom: 10px;
      }

      #typing-input:focus {
        outline: none;
        border-color: #3498db;
      }

      .player {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .player-color {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 10px;
      }

      #game-setup {
        background-color: rgba(0, 0, 0, 0.8);
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
      }

      #setup-panel {
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 500px;
        width: 90%;
      }

      .option-buttons {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        border-bottom: 1px solid #eee;
        padding-bottom: 15px;
      }

      .option-btn {
        background-color: #f8f9fa;
        border: none;
        padding: 10px 15px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
      }

      .option-btn.active {
        background-color: #3498db;
        color: white;
      }

      .option-btn:hover:not(.active) {
        background-color: #e9ecef;
      }

      .option-panel {
        display: none;
      }

      .option-panel.active {
        display: block;
      }

      .option-panel input {
        display: block;
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      #create-game,
      #join-game,
      #find-match,
      #start-game,
      #copy-game-id,
      #cancel-matchmaking {
        background-color: #2ecc71;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 4px;
        cursor: pointer;
        margin: 10px 5px;
        width: calc(100% - 10px);
      }

      #copy-game-id,
      #cancel-matchmaking {
        background-color: #e74c3c;
      }

      #start-game {
        background-color: #3498db;
      }

      #create-game:hover,
      #join-game:hover,
      #find-match:hover,
      #start-game:hover {
        opacity: 0.9;
      }

      .game-id {
        background-color: #f8f9fa;
        border: 1px dashed #ccc;
        padding: 12px;
        margin: 10px 0;
        font-size: 18px;
        font-weight: bold;
        border-radius: 4px;
        user-select: all;
      }

      .loading-spinner {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .player-list {
        margin: 15px 0;
        text-align: left;
      }

      .waiting-message {
        margin: 10px 0;
        font-style: italic;
        color: #7f8c8d;
      }

      #game-over {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 100;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      #game-results {
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        max-width: 500px;
        width: 90%;
        text-align: center;
      }

      #play-again {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 20px;
      }

      #play-again:hover {
        background-color: #2980b9;
      }

      .progress-container {
        height: 6px;
        width: 100%;
        background-color: #ecf0f1;
        border-radius: 3px;
        margin-top: 5px;
      }

      .progress-bar {
        height: 100%;
        border-radius: 3px;
        transition: width 0.2s;
      }
    </style>
  </head>
  <body>
    <!-- Game setup modal -->
    <div id="game-setup">
      <div id="setup-panel">
        <h2>Territory Typer</h2>
        <p>
          Compete to claim territories by typing phrases faster than your
          opponents!
        </p>

        <div id="game-options">
          <div class="option-buttons">
            <button id="create-game-btn" class="option-btn active">
              Create Game
            </button>
            <button id="join-game-btn" class="option-btn">Join Game</button>
            <button id="random-match-btn" class="option-btn">
              Random Match
            </button>
          </div>

          <!-- Create Game Panel -->
          <div id="create-game-panel" class="option-panel active">
            <input
              type="text"
              id="create-player-name"
              placeholder="Enter your nickname"
              maxlength="15"
            />
            <button id="create-game">Create Game Room</button>

            <div id="game-created" style="display: none">
              <p>Share this game ID with your friends:</p>
              <div id="game-id-display" class="game-id"></div>
              <button id="copy-game-id">Copy Game ID</button>

              <div class="player-list">
                <h3>Players in room:</h3>
                <ul id="host-players-list">
                  <!-- Player names will be added here -->
                </ul>
              </div>

              <button id="start-game">Start Game</button>
              <p class="waiting-message">Waiting for players to join...</p>
            </div>
          </div>

          <!-- Join Game Panel -->
          <div id="join-game-panel" class="option-panel">
            <input
              type="text"
              id="join-player-name"
              placeholder="Enter your nickname"
              maxlength="15"
            />
            <input type="text" id="game-id-input" placeholder="Enter Game ID" />
            <button id="join-game">Join Game</button>

            <div id="joined-game" style="display: none">
              <div class="player-list">
                <h3>Players in room:</h3>
                <ul id="guest-players-list">
                  <!-- Player names will be added here -->
                </ul>
              </div>
              <p class="waiting-message">
                Waiting for host to start the game...
              </p>
            </div>
          </div>

          <!-- Random Match Panel -->
          <div id="random-match-panel" class="option-panel">
            <input
              type="text"
              id="random-player-name"
              placeholder="Enter your nickname"
              maxlength="15"
            />
            <button id="find-match">Find Match</button>

            <div id="finding-match" style="display: none">
              <div class="loading-spinner"></div>
              <p class="waiting-message">Finding a match...</p>
              <button id="cancel-matchmaking">Cancel</button>

              <div class="player-list" style="display: none">
                <h3>Match found! Players:</h3>
                <ul id="random-players-list">
                  <!-- Player names will be added here -->
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Main game container -->
    <div id="game-container">
      <header>
        <h1>Territory Typer</h1>
        <p>Type the phrases faster than your opponents to claim territories!</p>
      </header>

      <div id="game-info">
        <div id="timer">3:00</div>
        <div id="scores">
          <!-- Player scores will be added here -->
        </div>
      </div>

      <div id="map-container">
        <!-- SVG Map will be inserted here -->
        <svg viewBox="0 0 1000 500" width="100%" height="100%" id="world-map">
          <!-- Example territories - these would be generated with actual world map paths -->
          <path
            class="territory"
            id="north-america"
            d="M150,120 L200,100 L280,150 L250,200 L180,220 L120,200 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="North America"
          ></path>
          <path
            class="territory"
            id="south-america"
            d="M220,230 L260,250 L240,320 L190,340 L170,290 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="South America"
          ></path>
          <path
            class="territory"
            id="europe"
            d="M420,120 L480,100 L510,140 L460,180 L430,160 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="Europe"
          ></path>
          <path
            class="territory"
            id="africa"
            d="M420,190 L490,190 L520,260 L480,320 L420,310 L390,250 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="Africa"
          ></path>
          <path
            class="territory"
            id="asia"
            d="M520,100 L650,120 L700,180 L620,250 L520,220 L490,170 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="Asia"
          ></path>
          <path
            class="territory"
            id="oceania"
            d="M700,280 L750,290 L760,320 L730,350 L690,330 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="Oceania"
          ></path>
          <path
            class="territory"
            id="antarctica"
            d="M300,400 L450,420 L600,410 L550,450 L350,450 Z"
            fill="#eee"
            stroke="#ccc"
            data-name="Antarctica"
          ></path>
        </svg>
      </div>

      <div id="typing-area">
        <div id="current-phrase">Click on a territory to start typing!</div>
        <input
          type="text"
          id="typing-input"
          placeholder="Type here..."
          disabled
        />

        <div id="active-players">
          <!-- Active players will be displayed here -->
        </div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
      <div id="game-results">
        <h2>Game Over!</h2>
        <div id="final-scores">
          <!-- Final scores will be added here -->
        </div>
        <button id="play-again">Play Again</button>
      </div>
    </div>

    <script>
      // Game state
      const gameState = {
        isActive: false,
        players: [],
        territories: [
          {
            id: 'north-america',
            name: 'North America',
            phrase: 'Vast plains and towering mountains',
            owner: null,
            x: 180,
            y: 150,
          },
          {
            id: 'south-america',
            name: 'South America',
            phrase: 'Amazon rainforest and Andes peaks',
            owner: null,
            x: 220,
            y: 290,
          },
          {
            id: 'europe',
            name: 'Europe',
            phrase: 'Ancient castles and modern capitals',
            owner: null,
            x: 450,
            y: 130,
          },
          {
            id: 'africa',
            name: 'Africa',
            phrase: 'Sahara desert and savanna wildlife',
            owner: null,
            x: 450,
            y: 250,
          },
          {
            id: 'asia',
            name: 'Asia',
            phrase: 'Himalayan heights and sprawling cities',
            owner: null,
            x: 600,
            y: 180,
          },
          {
            id: 'oceania',
            name: 'Oceania',
            phrase: 'Island paradise with coral reefs',
            owner: null,
            x: 720,
            y: 310,
          },
          {
            id: 'antarctica',
            name: 'Antarctica',
            phrase: 'Frozen tundra and scientific research',
            owner: null,
            x: 450,
            y: 420,
          },
        ],
        currentPlayer: null,
        selectedTerritory: null,
        gameTimeInSeconds: 180, // 3 minutes
        timeRemaining: 180,
        timerInterval: null,
        playerColors: [
          '#e74c3c',
          '#3498db',
          '#2ecc71',
          '#9b59b6',
          '#f39c12',
          '#1abc9c',
        ], // Red, Blue, Green, Purple, Orange, Teal
        gameId: null,
        isHost: false,
        gameMode: null, // 'create', 'join', or 'random'
        availableGames: [], // For random matchmaking
        matchmakingInterval: null,
      };

      // DOM Elements
      const elements = {
        setupPanel: document.getElementById('game-setup'),

        // Option buttons
        createGameBtn: document.getElementById('create-game-btn'),
        joinGameBtn: document.getElementById('join-game-btn'),
        randomMatchBtn: document.getElementById('random-match-btn'),

        // Create game panel
        createGamePanel: document.getElementById('create-game-panel'),
        createPlayerName: document.getElementById('create-player-name'),
        createGameButton: document.getElementById('create-game'),
        gameCreatedDiv: document.getElementById('game-created'),
        gameIdDisplay: document.getElementById('game-id-display'),
        copyGameIdBtn: document.getElementById('copy-game-id'),
        hostPlayersList: document.getElementById('host-players-list'),
        startGameBtn: document.getElementById('start-game'),

        // Join game panel
        joinGamePanel: document.getElementById('join-game-panel'),
        joinPlayerName: document.getElementById('join-player-name'),
        gameIdInput: document.getElementById('game-id-input'),
        joinGameButton: document.getElementById('join-game'),
        joinedGameDiv: document.getElementById('joined-game'),
        guestPlayersList: document.getElementById('guest-players-list'),

        // Random match panel
        randomMatchPanel: document.getElementById('random-match-panel'),
        randomPlayerName: document.getElementById('random-player-name'),
        findMatchBtn: document.getElementById('find-match'),
        findingMatchDiv: document.getElementById('finding-match'),
        cancelMatchmakingBtn: document.getElementById('cancel-matchmaking'),
        randomPlayersList: document.getElementById('random-players-list'),

        // Game elements
        mapContainer: document.getElementById('map-container'),
        worldMap: document.getElementById('world-map'),
        currentPhrase: document.getElementById('current-phrase'),
        typingInput: document.getElementById('typing-input'),
        timer: document.getElementById('timer'),
        scores: document.getElementById('scores'),
        activePlayers: document.getElementById('active-players'),
        gameOver: document.getElementById('game-over'),
        finalScores: document.getElementById('final-scores'),
        playAgainBtn: document.getElementById('play-again'),
      };

      // Initialize territory labels
      function initTerritoryLabels() {
        gameState.territories.forEach((territory) => {
          const label = document.createElement('div');
          label.className = 'territory-label';
          label.textContent = territory.name;
          label.style.left = `${territory.x}px`;
          label.style.top = `${territory.y}px`;
          elements.mapContainer.appendChild(label);
        });
      }

      // Attach event listeners to territories
      function attachTerritoryEvents() {
        document.querySelectorAll('.territory').forEach((territoryEl) => {
          territoryEl.addEventListener('click', () => {
            if (!gameState.isActive) return;

            const territory = gameState.territories.find(
              (t) => t.id === territoryEl.id
            );
            if (territory) {
              selectTerritory(territory);
            }
          });
        });
      }

      // Select a territory to claim
      function selectTerritory(territory) {
        if (territory.owner === gameState.currentPlayer.id) {
          elements.currentPhrase.textContent = `You already own ${territory.name}!`;
          return;
        }

        gameState.selectedTerritory = territory;
        elements.currentPhrase.textContent = `Type: "${territory.phrase}"`;
        elements.typingInput.value = '';
        elements.typingInput.disabled = false;
        elements.typingInput.focus();

        // Simulate other players attempting to type the same phrase
        simulateOpponentTyping(territory);
      }

      // Check typing accuracy and handle territory claim
      elements.typingInput.addEventListener('input', () => {
        if (!gameState.selectedTerritory) return;

        const targetPhrase = gameState.selectedTerritory.phrase;
        const typedText = elements.typingInput.value;

        // Check if the typed text matches the phrase
        if (typedText === targetPhrase) {
          claimTerritory(
            gameState.selectedTerritory,
            gameState.currentPlayer.id
          );
          elements.currentPhrase.textContent = `You claimed ${gameState.selectedTerritory.name}!`;
          elements.typingInput.value = '';
          elements.typingInput.disabled = true;
          gameState.selectedTerritory = null;
          updateScores();
        }
      });

      // Claim a territory for a player
      function claimTerritory(territory, playerId) {
        territory.owner = playerId;
        const territoryEl = document.getElementById(territory.id);

        // Find player color
        const player = gameState.players.find((p) => p.id === playerId);
        if (player) {
          territoryEl.setAttribute('fill', player.color);
          territoryEl.setAttribute('stroke', '#666');
        }
      }

      // Simulate opponent typing behavior
      function simulateOpponentTyping(territory) {
        // Only simulate for AI opponents or in single player mode
        if (
          gameState.gameMode === 'random' ||
          gameState.gameMode === 'join' ||
          gameState.gameMode === 'create'
        ) {
          // In multiplayer modes, don't simulate other real players
          if (
            gameState.players.filter(
              (p) => p.id.toString().indexOf('ai-') !== 0
            ).length > 1
          ) {
            // There are other human players, so don't simulate typing
            return;
          }
        }

        // Add AI opponents if needed in single player mode
        if (gameState.players.length === 1 && gameState.isActive) {
          // Add 2 AI opponents for single player
          for (let i = 1; i <= 2; i++) {
            const aiPlayer = {
              id: `ai-${i}`,
              name: `AI Player ${i}`,
              score: 0,
              color: gameState.playerColors[i % gameState.playerColors.length],
              isAI: true,
            };
            gameState.players.push(aiPlayer);
          }
          updateScores();
        }

        // Only simulate for AI opponents, not human players
        const aiOpponents = gameState.players.filter((p) => p.isAI === true);

        aiOpponents.forEach((opponent) => {
          // Random typing speed between 50-80 characters per minute
          const typingSpeed = 50 + Math.floor(Math.random() * 30);
          const phrase = territory.phrase;
          const timeToComplete = (phrase.length / typingSpeed) * 60 * 1000; // in milliseconds

          // Randomly add errors that need correction (increasing time)
          const errorFactor = 1 + Math.random() * 0.3; // 0-30% increase in time due to errors
          const actualTimeToComplete = timeToComplete * errorFactor;

          setTimeout(() => {
            // Only claim if game is still active and territory isn't already claimed
            if (gameState.isActive && territory.owner === null) {
              claimTerritory(territory, opponent.id);
              updateScores();

              // If the current player was typing for this territory, notify them
              if (
                gameState.selectedTerritory &&
                gameState.selectedTerritory.id === territory.id
              ) {
                elements.currentPhrase.textContent = `${opponent.name} claimed ${territory.name} before you!`;
                elements.typingInput.disabled = true;
                gameState.selectedTerritory = null;
              }
            }
          }, actualTimeToComplete);
        });
      }

      // Update the game timer
      function updateTimer() {
        gameState.timeRemaining--;

        const minutes = Math.floor(gameState.timeRemaining / 60);
        const seconds = gameState.timeRemaining % 60;
        elements.timer.textContent = `${minutes}:${seconds
          .toString()
          .padStart(2, '0')}`;

        if (gameState.timeRemaining <= 0) {
          endGame();
        }
      }

      // Update player scores display
      function updateScores() {
        // Calculate scores (territories owned)
        gameState.players.forEach((player) => {
          player.score = gameState.territories.filter(
            (t) => t.owner === player.id
          ).length;
        });

        // Update score display
        elements.scores.innerHTML = '';
        gameState.players.forEach((player) => {
          const playerScore = document.createElement('div');
          playerScore.className = 'player';

          const colorBox = document.createElement('div');
          colorBox.className = 'player-color';
          colorBox.style.backgroundColor = player.color;

          playerScore.appendChild(colorBox);
          playerScore.appendChild(
            document.createTextNode(
              `${player.name}: ${player.score} territories`
            )
          );
          elements.scores.appendChild(playerScore);
        });
      }

      // Start the game
      function startGame() {
        gameState.isActive = true;
        gameState.timeRemaining = gameState.gameTimeInSeconds;
        elements.setupPanel.style.display = 'none';

        // Reset any previous game state
        gameState.territories.forEach((territory) => {
          territory.owner = null;
          document.getElementById(territory.id).setAttribute('fill', '#eee');
          document.getElementById(territory.id).setAttribute('stroke', '#ccc');
        });

        // Update display
        updateScores();
        elements.currentPhrase.textContent =
          'Click on a territory to start typing!';

        // Start timer
        gameState.timerInterval = setInterval(updateTimer, 1000);

        // For real-time game, setup territory claiming sync (would use WebSockets in a real app)
        if (gameState.gameMode === 'join' || gameState.gameMode === 'random') {
          const territorySyncInterval = setInterval(() => {
            // In a real app, this would be a WebSocket message handler
            // Here we're just simulating territory claiming by other players
            if (!gameState.isActive) {
              clearInterval(territorySyncInterval);
              return;
            }

            // Simulate random territory claims by other players at random intervals
            // In a real app, this would be actual real-time player actions
            const otherPlayers = gameState.players.filter(
              (p) => p.id !== gameState.currentPlayer.id && !p.isAI
            );

            if (otherPlayers.length > 0) {
              const randomPlayer =
                otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
              const unclaimedTerritories = gameState.territories.filter(
                (t) => t.owner === null
              );

              if (unclaimedTerritories.length > 0 && Math.random() < 0.1) {
                // 10% chance each check
                const randomTerritory =
                  unclaimedTerritories[
                    Math.floor(Math.random() * unclaimedTerritories.length)
                  ];

                // Claim territory for the random player
                claimTerritory(randomTerritory, randomPlayer.id);
                updateScores();

                // Notify current player if they were trying to claim this territory
                if (
                  gameState.selectedTerritory &&
                  gameState.selectedTerritory.id === randomTerritory.id
                ) {
                  elements.currentPhrase.textContent = `${randomPlayer.name} claimed ${randomTerritory.name} before you!`;
                  elements.typingInput.disabled = true;
                  gameState.selectedTerritory = null;
                }
              }
            }
          }, 2000); // Check every 2 seconds

          gameState.territorySyncInterval = territorySyncInterval;
        }
      }

      // End the game
      function endGame() {
        gameState.isActive = false;
        clearInterval(gameState.timerInterval);

        if (gameState.territorySyncInterval) {
          clearInterval(gameState.territorySyncInterval);
        }

        if (gameState.gameId) {
          gameServer.endGame(gameState.gameId);
        }

        // Sort players by score
        const sortedPlayers = [...gameState.players].sort(
          (a, b) => b.score - a.score
        );

        // Display final scores
        elements.finalScores.innerHTML = '<h3>Final Standings:</h3>';
        sortedPlayers.forEach((player, index) => {
          const playerResult = document.createElement('div');
          playerResult.innerHTML = `${index + 1}. <span style="color:${
            player.color
          }">${player.name}</span>: ${player.score} territories`;
          elements.finalScores.appendChild(playerResult);
        });

        // Show game over screen
        elements.gameOver.style.display = 'flex';
      }

      // Helper function to generate a random game ID
      function generateGameId() {
        const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed similar looking characters
        let result = '';
        for (let i = 0; i < 6; i++) {
          result += characters.charAt(
            Math.floor(Math.random() * characters.length)
          );
        }
        return result;
      }

      // Helper function to show the active games for debugging
      window.debugShowGames = function () {
        console.log('Active games:', Object.keys(gameServer.games));
        return Object.keys(gameServer.games);
      };

      // Make game server globally accessible for debugging
      window.gameServer = {
        games: {},
        waitingGames: [], // Queue for random matchmaking

        createGame(hostName) {
          const gameId = generateGameId();
          const hostPlayer = {
            id: Date.now().toString(),
            name: hostName,
            score: 0,
            color: gameState.playerColors[0],
            isHost: true,
          };

          this.games[gameId] = {
            id: gameId,
            players: [hostPlayer],
            status: 'waiting', // waiting, playing, ended
            createdAt: Date.now(),
          };

          console.log(`Game created: ${gameId} with host: ${hostName}`);
          console.log('Current games:', Object.keys(this.games));

          return { gameId, player: hostPlayer };
        },

        joinGame(gameId, playerName) {
          // First, normalize the gameId (in case it's lowercase or has whitespace)
          gameId = gameId.trim().toUpperCase();

          // Check if game exists
          if (!this.games[gameId]) {
            return {
              success: false,
              message: 'Game not found. Check the Game ID and try again.',
            };
          }

          // Check if game is already in progress or ended
          if (
            this.games[gameId].status === 'playing' ||
            this.games[gameId].status === 'ended'
          ) {
            return {
              success: false,
              message: 'This game has already started or ended.',
            };
          }

          const game = this.games[gameId];

          if (game.players.length >= 6) {
            return {
              success: false,
              message: 'Game is full (maximum 6 players).',
            };
          }

          // Check if player name is already taken in this game
          if (
            game.players.some(
              (p) => p.name.toLowerCase() === playerName.toLowerCase()
            )
          ) {
            return {
              success: false,
              message:
                'Someone with this name is already in the game. Please use a different name.',
            };
          }

          const newPlayer = {
            id: Date.now().toString(),
            name: playerName,
            score: 0,
            color:
              gameState.playerColors[
                game.players.length % gameState.playerColors.length
              ],
            isHost: false,
          };

          game.players.push(newPlayer);

          // For debugging
          console.log(
            `Player ${playerName} joined game ${gameId}. Total players: ${game.players.length}`
          );

          return { success: true, game, player: newPlayer };
        },

        addToMatchmaking(playerName) {
          const playerId = Date.now().toString();
          const player = {
            id: playerId,
            name: playerName,
            score: 0,
            color: null,
            isHost: false,
          };

          // Check if there's a waiting game with space
          if (this.waitingGames.length > 0) {
            const oldestGameId = this.waitingGames[0];
            const game = this.games[oldestGameId];

            if (game && game.status === 'waiting' && game.players.length < 6) {
              // Join existing game
              player.color =
                gameState.playerColors[
                  game.players.length % gameState.playerColors.length
                ];
              game.players.push(player);

              // If we have 3 players, start the game
              if (game.players.length === 3) {
                game.status = 'ready';
                this.waitingGames.shift(); // Remove from waiting queue
              }

              return {
                success: true,
                gameId: oldestGameId,
                game,
                player,
                status: game.status,
              };
            }
          }

          // Create a new game
          const gameId = generateGameId();
          player.color = gameState.playerColors[0];
          player.isHost = true;

          this.games[gameId] = {
            id: gameId,
            players: [player],
            status: 'waiting',
            createdAt: Date.now(),
          };

          this.waitingGames.push(gameId);

          return {
            success: true,
            gameId,
            game: this.games[gameId],
            player,
            status: 'waiting',
          };
        },

        removeFromMatchmaking(gameId) {
          this.waitingGames = this.waitingGames.filter((id) => id !== gameId);
          if (this.games[gameId]) {
            delete this.games[gameId];
          }
        },

        startGame(gameId) {
          if (this.games[gameId]) {
            this.games[gameId].status = 'playing';
            // Remove from waiting queue if it's there
            this.waitingGames = this.waitingGames.filter((id) => id !== gameId);
            return true;
          }
          return false;
        },

        endGame(gameId) {
          if (this.games[gameId]) {
            this.games[gameId].status = 'ended';
            return true;
          }
          return false;
        },

        getGame(gameId) {
          // Normalize the game ID
          gameId = gameId.trim().toUpperCase();
          console.log(
            `Getting game: ${gameId}`,
            this.games[gameId] ? 'Found' : 'Not found'
          );
          return this.games[gameId] || null;
        },

        getPlayers(gameId) {
          return this.games[gameId] ? this.games[gameId].players : [];
        },
      };

      // Function to update player lists
      function updatePlayersList(listElement, players) {
        listElement.innerHTML = '';
        players.forEach((player) => {
          const playerItem = document.createElement('li');
          playerItem.style.color = player.color;
          playerItem.innerHTML = `${player.name} ${
            player.isHost ? '(Host)' : ''
          }`;
          listElement.appendChild(playerItem);
        });
      }

      // Add a method to check if a game exists for debugging
      window.checkGameExists = function (gameId) {
        if (!gameId) {
          if (gameState.gameId) {
            gameId = gameState.gameId;
          } else {
            return 'No current game ID';
          }
        }
        return window.gameServer.games[gameId]
          ? 'Game exists'
          : 'Game does not exist';
      };

      // Tab switching functionality
      elements.createGameBtn.addEventListener('click', () => {
        elements.createGameBtn.classList.add('active');
        elements.joinGameBtn.classList.remove('active');
        elements.randomMatchBtn.classList.remove('active');

        elements.createGamePanel.classList.add('active');
        elements.joinGamePanel.classList.remove('active');
        elements.randomMatchPanel.classList.remove('active');
      });

      elements.joinGameBtn.addEventListener('click', () => {
        elements.createGameBtn.classList.remove('active');
        elements.joinGameBtn.classList.add('active');
        elements.randomMatchBtn.classList.remove('active');

        elements.createGamePanel.classList.remove('active');
        elements.joinGamePanel.classList.add('active');
        elements.randomMatchPanel.classList.remove('active');
      });

      elements.randomMatchBtn.addEventListener('click', () => {
        elements.createGameBtn.classList.remove('active');
        elements.joinGameBtn.classList.remove('active');
        elements.randomMatchBtn.classList.add('active');

        elements.createGamePanel.classList.remove('active');
        elements.joinGamePanel.classList.remove('active');
        elements.randomMatchPanel.classList.add('active');
      });

      // Create game functionality
      elements.createGameButton.addEventListener('click', () => {
        const playerName = elements.createPlayerName.value.trim();
        if (!playerName) {
          alert('Please enter your nickname');
          return;
        }

        // Create a new game
        const { gameId, player } = window.gameServer.createGame(playerName);

        // Log for debugging
        console.log(`Game created with ID: ${gameId}`);
        console.log('Active games:', Object.keys(window.gameServer.games));

        // Update game state
        gameState.gameId = gameId;
        gameState.isHost = true;
        gameState.gameMode = 'create';
        gameState.players = [player];
        gameState.currentPlayer = player;

        // Update UI
        elements.createPlayerName.disabled = true;
        elements.createGameButton.style.display = 'none';
        elements.gameCreatedDiv.style.display = 'block';
        elements.gameIdDisplay.textContent = gameId;

        // Add player to the list
        updatePlayersList(elements.hostPlayersList, [player]);

        // Setup polling for new players (in a real app, this would be WebSockets)
        const pollInterval = setInterval(() => {
          const currentGame = window.gameServer.getGame(gameId);
          if (
            currentGame &&
            currentGame.players.length !== gameState.players.length
          ) {
            gameState.players = currentGame.players;
            updatePlayersList(elements.hostPlayersList, currentGame.players);
          }
        }, 1000);

        // Store the interval to clear it later
        gameState.pollInterval = pollInterval;
      });

      // Copy game ID functionality
      elements.copyGameIdBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(gameState.gameId).then(() => {
          elements.copyGameIdBtn.textContent = 'Copied!';
          setTimeout(() => {
            elements.copyGameIdBtn.textContent = 'Copy Game ID';
          }, 2000);
        });
      });

      // Join game functionality
      elements.joinGameButton.addEventListener('click', () => {
        const playerName = elements.joinPlayerName.value.trim();
        const gameId = elements.gameIdInput.value.trim().toUpperCase();

        if (!playerName || !gameId) {
          alert('Please enter both your name and the game ID');
          return;
        }

        console.log('Attempting to join game:', gameId);
        console.log('Active games:', Object.keys(window.gameServer.games));

        // Try to join the game
        const result = window.gameServer.joinGame(gameId, playerName);

        if (result.success) {
          // Update game state
          gameState.gameId = gameId;
          gameState.isHost = false;
          gameState.gameMode = 'join';
          gameState.players = result.game.players;
          gameState.currentPlayer = result.player;

          // Update UI
          elements.joinPlayerName.disabled = true;
          elements.gameIdInput.disabled = true;
          elements.joinGameButton.style.display = 'none';
          elements.joinedGameDiv.style.display = 'block';

          // Add players to the list
          updatePlayersList(elements.guestPlayersList, result.game.players);

          // Setup polling for game status (in a real app, this would be WebSockets)
          const pollInterval = setInterval(() => {
            const currentGame = window.gameServer.getGame(gameId);
            if (currentGame) {
              if (currentGame.status === 'playing' && !gameState.isActive) {
                clearInterval(pollInterval);
                startGame();
              } else if (
                currentGame.players.length !== gameState.players.length
              ) {
                gameState.players = currentGame.players;
                updatePlayersList(
                  elements.guestPlayersList,
                  currentGame.players
                );
              }
            } else {
              // Game no longer exists
              clearInterval(pollInterval);
              alert('The game room was closed by the host');

              // Reset UI
              elements.joinPlayerName.disabled = false;
              elements.gameIdInput.disabled = false;
              elements.joinGameButton.style.display = 'block';
              elements.joinedGameDiv.style.display = 'none';

              // Reset game state
              gameState.gameId = null;
              gameState.isHost = false;
              gameState.gameMode = null;
              gameState.players = [];
              gameState.currentPlayer = null;
            }
          }, 1000);

          // Store the interval to clear it later
          gameState.pollInterval = pollInterval;
        } else {
          alert(result.message);
        }
      });

      // Random matchmaking functionality
      elements.findMatchBtn.addEventListener('click', () => {
        const playerName = elements.randomPlayerName.value.trim();
        if (!playerName) return;

        // Add to matchmaking
        const result = gameServer.addToMatchmaking(playerName);

        if (result.success) {
          // Update game state
          gameState.gameId = result.gameId;
          gameState.isHost = result.player.isHost;
          gameState.gameMode = 'random';
          gameState.players = result.game.players;
          gameState.currentPlayer = result.player;

          // Update UI
          elements.randomPlayerName.disabled = true;
          elements.findMatchBtn.style.display = 'none';
          elements.findingMatchDiv.style.display = 'block';

          // If the game is ready to start
          if (result.status === 'ready') {
            document.querySelector(
              '#finding-match .player-list'
            ).style.display = 'block';
            updatePlayersList(elements.randomPlayersList, result.game.players);

            setTimeout(() => {
              startGame();
            }, 3000); // Give players 3 seconds to see who they matched with
          } else {
            // Setup polling for matchmaking status
            const matchmakingInterval = setInterval(() => {
              const currentGame = gameServer.getGame(result.gameId);
              if (currentGame) {
                if (
                  currentGame.status === 'ready' ||
                  currentGame.status === 'playing'
                ) {
                  gameState.players = currentGame.players;
                  document.querySelector(
                    '#finding-match .player-list'
                  ).style.display = 'block';
                  updatePlayersList(
                    elements.randomPlayersList,
                    currentGame.players
                  );

                  clearInterval(matchmakingInterval);

                  setTimeout(() => {
                    startGame();
                  }, 3000);
                } else if (
                  currentGame.players.length !== gameState.players.length
                ) {
                  gameState.players = currentGame.players;
                  updatePlayersList(
                    elements.randomPlayersList,
                    currentGame.players
                  );
                }
              }
            }, 1000);

            gameState.matchmakingInterval = matchmakingInterval;
          }
        } else {
          alert('Failed to join matchmaking. Please try again.');
        }
      });

      // Cancel matchmaking
      elements.cancelMatchmakingBtn.addEventListener('click', () => {
        if (gameState.gameId) {
          // Remove from matchmaking
          gameServer.removeFromMatchmaking(gameState.gameId);

          // Reset UI
          elements.randomPlayerName.disabled = false;
          elements.findMatchBtn.style.display = 'block';
          elements.findingMatchDiv.style.display = 'none';
          document.querySelector('#finding-match .player-list').style.display =
            'none';

          // Clear polling interval
          if (gameState.matchmakingInterval) {
            clearInterval(gameState.matchmakingInterval);
          }

          // Reset game state
          gameState.gameId = null;
          gameState.isHost = false;
          gameState.gameMode = null;
          gameState.players = [];
          gameState.currentPlayer = null;
        }
      });

      // Start game (host only)
      elements.startGameBtn.addEventListener('click', () => {
        if (gameState.isHost && gameState.players.length >= 1) {
          window.gameServer.startGame(gameState.gameId);
          startGame();
        }
      });

      // Play again button
      elements.playAgainBtn.addEventListener('click', () => {
        elements.gameOver.style.display = 'none';
        elements.setupPanel.style.display = 'flex';

        // Clear game state
        if (gameState.pollInterval) {
          clearInterval(gameState.pollInterval);
        }

        if (gameState.matchmakingInterval) {
          clearInterval(gameState.matchmakingInterval);
        }

        // Reset UI for all panels
        elements.createPlayerName.disabled = false;
        elements.createPlayerName.value = '';
        elements.createGameButton.style.display = 'block';
        elements.gameCreatedDiv.style.display = 'none';
        elements.hostPlayersList.innerHTML = '';

        elements.joinPlayerName.disabled = false;
        elements.joinPlayerName.value = '';
        elements.gameIdInput.disabled = false;
        elements.gameIdInput.value = '';
        elements.joinGameButton.style.display = 'block';
        elements.joinedGameDiv.style.display = 'none';
        elements.guestPlayersList.innerHTML = '';

        elements.randomPlayerName.disabled = false;
        elements.randomPlayerName.value = '';
        elements.findMatchBtn.style.display = 'block';
        elements.findingMatchDiv.style.display = 'none';
        elements.randomPlayersList.innerHTML = '';

        // Reset game state
        gameState.gameId = null;
        gameState.isHost = false;
        gameState.gameMode = null;
        gameState.players = [];
        gameState.currentPlayer = null;
      });

      // Add a button for testing game functionality
      const debugDiv = document.createElement('div');
      debugDiv.style.position = 'fixed';
      debugDiv.style.bottom = '10px';
      debugDiv.style.right = '10px';
      debugDiv.style.padding = '10px';
      debugDiv.style.background = 'rgba(0,0,0,0.5)';
      debugDiv.style.color = 'white';
      debugDiv.style.borderRadius = '5px';
      debugDiv.style.zIndex = '1000';
      debugDiv.innerHTML = `
            <button id="debug-button" style="padding: 5px;">Debug</button>
            <div id="debug-output" style="margin-top: 5px; display: none;"></div>
        `;
      document.body.appendChild(debugDiv);

      document
        .getElementById('debug-button')
        .addEventListener('click', function () {
          const debugOutput = document.getElementById('debug-output');
          debugOutput.style.display =
            debugOutput.style.display === 'none' ? 'block' : 'none';
          if (debugOutput.style.display === 'block') {
            const games = window.debugShowGames();
            debugOutput.innerHTML = `
                    <p>Current Game ID: ${gameState.gameId || 'None'}</p>
                    <p>Active Games: ${games.length}</p>
                    <p>Game IDs: ${games.join(', ')}</p>
                `;
          }
        });

      // Initialize the game
      initTerritoryLabels();
      attachTerritoryEvents();
    </script>
  </body>
</html>
